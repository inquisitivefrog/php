
I am working as a Software Engineer. I need to use PHP on an upcoming project. I havenâ€™t used it since 2013 so quite likely many things have changed. You suggested developing an application that demonstrates use of PHP and Laravel with PostGreSQL so that I can become familiar with the many Lavarel features such as Pennant, Cashier, Breeze and others. I have a Ubuntu 24.04.3 VM with 12GB RAM, 15GB remaining disk and 8 CPU Cores on a MacBook Air with 20 FPUs and 24GB RAM. We are attempting to follow best practices and take appropriate security measures. We have the following layout so far. You have been providing file content as if this is old hat so I am dependent on your expertise. We have worked together for several days. This is what we have completed so far. If you need to see file content for clarity, just ask. We are trying to be both secure and state-of-the-art regarding Best Practices while showing off the Laravel features so feel free to offer suggestions. There is some history regarding decisions as well so please ask before speculating as it will save time. We appear to have a Laravel basic environment configured and deployed in Docker so php extensions and npm packages have been installed during build to ensure rapid deployment of new instances when auto scaling or replacing failed instances. We are now building an application that demonstrates the various features of the framework so I can gain familiarity? I would like feature demonstrated by app and validated by tests. You suggested these Laravel options in this image. I would also like to use current CI Pipeline tools for automated testing, syntax checking, static analysis, memory leaks, load testing, etc. I will rely on you to introduce me to them. 

sre@cpp:~/laravel-feature-lab$ pwd /home/sre/laravel-feature-lab sre@cpp:~/laravel-feature-lab$ 

find . -name "*.yml" -o -name "*.php" -o -name "*.js" -o -name "*.sh" -o -name "*.ini" -o -name "*.conf" -o -name "Dock*" -o -name "php*" -o -path ./src/storage/framework -prune -o -path ./src/vendor -prune -o -path ./src/node_modules -prune 

docker compose exec workspace bash 
composer show --direct | grep -v "laravel/framework" | grep -v "php " 

php vendor/bin/phpstan analyse --memory-limit=1G
./vendor/bin/pint 
php vendor/bin/php-cs-fixer fix --cache-file=/tmp/.php_cs.cache --dry-run --diff --verbose

I have been away from the PHP language since perhaps 2013 so I am refreshing with current tools as can be evident by README.now.txt.  The problem I am trying to solve is described in README.prompt.txt which I need to regurgitate every time a new session is started with ChatGPT or Grok or Gemini.  The find command in README.prune.txt helps me rapidly share the project directory tree.   However, use of these tools has been somewhat clumsy so if I can improve on that, it would be wonderful.  I have been letting the tools lead the way regarding how to code and what is current best practice.  I have several years experience in IT, Service, QA and Operations.  I also have a few years experience in Engineering.  I am well aware of the headache and reputation damage that can occur when a problem is found by a customer but also how code is often designed to allow Service staff an easy method to simulate the customer in order to reproduce the problem without troubling the customer further aside from Please Don't Do That Again Until We Understand And Fix It.  I have built Service and QA labs from scratch by evaluating technology, recommending, selecting, purchasing and installing it while in IT.  I have also managed hardware support contracts and scheduled repairs or even made repairs myself.  I have managed software support contracts counting heads to purchase annual licenses for use, reporting bugs and obtaining and installing patches or upgrades.    

I have provided first level support for software or appliances that failed in the field.  I have assisted with debugging over the phone and helped design tools to rapidly collect and share additional data as needed.  I have also provided second level support debugging application and kernel cores and even identified and patched simple problems detected.  I have worked with Software Engineers to get complicated problems understood and fixed and tested fixes by reproducing problems reported in the Service lab.  I have also worked as the Escalation Team Lead and worked with customers to reproduce problems difficult to reproduce in house and ensured that solutions provided are installed when convenient.

I have tested code writing and executing unit, api, UI, datastore, scenario and load, stress, duration and scalability tests.   I have argued passionately when P1 bugs get deferred or assisted Software Engineers by developing and executing additional tests that validate an environment and expected partial behavior of new features in order to narrow down the scope when debugging unexpected problems.  

I have developed code twice in my career.   Once as a basic level Software Engineer after attracting attention for tool development to support my QA team.  I developed database code primarily porting Oracle to MSSQL and ensuring that schema updates proceeded smoothly using Bash scripts.   Another time as a senior Software Engineer after refactoring startup code developed in haste so difficult to test in QA with automation.   I developed notification and authentication modules for a web application.  

Most recently, I have worked in Operations, first provisioning hardware as needed using remote resources managed by another team after obtaining permission to use it and requisitioning sufficient resources to support an application in development and later expanding resources to support application usage growth.  Virtualization and containerization methods were used to deploy different applications.  I managed CI/CD pipelines used to support pull requests and package artifacts stored and retrieved from an artifact repository.  I modified infrastructure configurations as needed using automation tools.  I monitored application behavior and enabled logging and alerting for all basic cases: failure, resource saturation, connectivity, latency.  
